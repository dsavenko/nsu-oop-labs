
# Задача 2. Sound Processor

WAV-файл представляет собой контейнер для хранения звукового потока. Он состоит из заголовка и данных в виде последовательности сэмплов. Сэмпл — это величина амплитуды звукового сигнала в каждый момент времени. Частота — это количество сэмплов в секунду. 

Напишите утилиту командной строки для конверсии звуковых файлов формата WAV. Программа получает на вход (в аргументах командной строки) набор исходных файлов (`input1.wav`, `input2.wav`, и т.д.), выходной файл (например, `output.wav`) и текстовый файл примерно следующего содержания:

```
# заглушить первые 30 секунд input1
mute 0 30
# смиксовать с input2, начиная с секунды 10
mix $2 10
# заглушить 3-ю минуту в миксованном потоке
mute 120 180
```
(синтаксис не обязательно такой, вы можете сделать по-своему).

На выходе программа создает выходной WAV-файл со звуком, соответствующим переданной конфигурации. Если выходной WAV-файл уже существует, программа должна его перезаписать. Программа **не должна** изменять входные файлы, она их только читает.

Поддерживаемые преобразования (конвертеры):

1. `mute` - заглушить интервал;
2. `mix` - смиксовать два файла (то есть, сэмпл на выходе будет средним значением сэмплов на входе).
3. Дополнительное уникальное (у каждого своё) преобразование. У него должен быть как минимум 1 аргумент, и результат его работы должен быть слышен. 

Перечисленные выше 3 конвертера должны быть реализованы **обязательно**. Сверх этого вы можете добавить любые другие конвертеры.

Для конверсии поддерживается только следующий формат входных файлов:

1. Аудио-формат PCM (без кодирования);
2. Моно-звук (1 канал);
3. Разрядность 16 бит со знаком (signed 16 bit (little-endian)) — это значит, что один сэмпл представлен целым 16-битным числом со знаком;
4. Частота 44100 Гц.

Получить звук в таком формате из любого другого можно с помощью утилиты [ffmpeg](https://ffmpeg.org/download.html) следующим образом:

```
> ffmpeg -i Radioactive.flac -f wav -bitexact -acodec pcm_s16le -ar 44100 -ac 1 "Radioactive_mono_16bit.wav"
```
(вместе `Radioactive.flac` подставьте любой звуковой файл).

Несколько готовых примеров музыки в этом формате лежат [здесь](https://drive.google.com/file/d/1wzvJK09WI7UzXciJLKjWT_w6g4JWruWJ/view?usp=sharing), можете воспользоваться ими.

> [!WARNING]  
> **Не надо коммитить музыку в Git!** Она занимает много места. Звуковые файлы держите за пределами папки с проектом.

**Технические условия:**

1. Программа должна быть написана в парадигме ООП.
2. Разделите код на логические части: работа с форматом WAV, конвертеры (преобразования), подготовка и исполнение процесса конверсии. Работа с WAV и конвертеры полностью независимы. Последняя часть связывает всё воедино через интерфейсы. Создание конвертеров реализуйте с помощью шаблона проектирования [«фабричный метод»](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)).

## Дополнительно

Дополнительные возможности, предлагаемые для реализации тем, кто сделает основное:

1. Вывод справки об использовании программы (аргумент командной строки `-h`).
2. Для обработки ошибок и исключительных ситуаций используйте механизм исключений C++. Разработайте иерархию исключений, которые будут выбрасываться при исполнении. При возникновении исключения программа выводит сообщение об ошибке в `std::cerr` и завершается с ненулевым кодом, различным для каждого типа ошибки.
3. Добавьте новые интересные конвертеры.
4. Сделайте так, чтобы количество используемой оперативной памяти не зависело от размера входных файлов.
5. Сделайте так, чтобы программа не создавала лишних (промежуточных) файлов. 
6. Выделите конвертеры в отдельную динамически линкуемую библиотеку (`.dll` для Windows, `.so` для Linux), чтобы её можно было подменить на другую и без пересборки программы получить другой набор поддерживаемых конвертеров. Для демонстрации вы должны собрать три артефакта: исполняемый файл программы и две отдельные динамические библиотеки с разным набором конвертеров. Далее, вы должны показать, что подмена одной библиотеки на другую (без пересборки кода, просто подмена файлов) приводит к тому, что программа начинает поддерживать другой набор конвертеров.
7. Улучшите поддержку заголовков WAV. Выводите на консоль информацию о названии и авторе входной музыки, в выходном файле корректно заполняйте эти поля. Если во входном файле есть картинка альбома, перенесите её в выходной файл.
8. Добавьте возможность вместо сохранения звука в выходной файл проигрывать его.
9. Добавьте в качестве возможного источника звука микрофон.
10. **Ваш вариант!** Вы можете придумать и реализовать любые улучшения.
