
# Задача 4. Metaprogramming (задача в разработке)

## Подзадача 1. Кортежи (tuples)

Реализуйте оператор для печати `std::tuple`. Должен работать код наподобие следующего:
```C++
// кортеж может быть любым возможным, не обязательно 3 этих типа
std::tuple<int, std::string, double> t = {5, "abcd", 3.14};
// выводит (5, abcd, 3.14). Вместо std::cout может быть файловый поток
std::cout << t; 
```
Вы ограничены возможностями стандарта С++11. Это означает, что нельзя, например, использовать `if constexpr`, `std::integer_sequence/index_sequence` и fold expressions, т.к. они появились в более поздних версиях. Вам нужно решить задачу, используя только рекурсивные шаблоны и специализацию шаблонов.

Дополнительно: 

1. Сделайте другую реализацию, на этот раз используя `if constexpr`. Возможно, вы также найдете применение `std::integer_sequence/index_sequence` и fold expressions.
2. Реализуйте собственный вариант шаблонного класса `tuple`.

## Подзадача 2. Обобщённый Flat Map

Превратите ваш класс `FlatMap` из первой задачи в шаблонный класс, поддерживающий любые типы ключей (для которых определён `operator<`) и любые типы значений (для которых определён конструктор без параметров).

```C++
template <class Key, class Value>
class FlatMap {
    // ...
}
```

> [!NOTE]
> Если в первой задаче вы не сделали итераторы, реализуйте их сейчас. Итераторы - часть минимальных требований данной задачи.
>
> Если вы не делали первую задачу совсем, вам нужно сразу написать шаблонный класс FlatMap, удовлетворяющий минимальным условиям 1-й задачи + итераторы. Другие допы первой задачи делать не обязательно.

Дополнительно: 

1. К шаблонным параметрам `Key` и `Value` добавьте `Compare` и `Allocator`, определяющие политики сравнения ключей и выделения памяти. 
    ```C++
    template <class Key,
              class Value,
              class Compare = std::less<Key>,
              class Allocator = std::allocator<...>
             >
    class FlatMap {
        // ...
    }
    ```
    Работайте с аллокатором не напрямую, а через шаблон `std::allocator_traits`.

    1.1. Продемонстрируйте, как можно использовать в качестве ключа тип, для которого не перегружены операторы сравнения (например, `<`).

3. Реализуйте собственный аллокатор, который выделяет большой кусок памяти (пул) один раз при создании. Его метод `allocate` не делает реального выделения памяти, а лишь возвращает указатель на свободный участок из этого пула, а метод `deallocate` просто ничего не делает. Убедитесь, что с вашим аллокатором корректно работает как ваш класс `FlatMap`, так и стандартные контейнеры (например, `std::vector` или `std::list`). Продемонстрируйте разницу в производительности контейнера `std::list` со стандартным аллокатором и с вашим.

    2.1. Реализуйте метод `deallocate` так, чтобы освобожденное место в пуле можно было использовать повторно.

4. Сделайте специализацию таблицы для значений типа `bool` (`Value = bool`). Эта специализация хранит только значения `true`, а `false` не хранится. Присвоение ключу значения `false` равноценно удалению ключа из таблицы. Из допов данной задачи эта специализация должна использовать **аллокаторы** и реализовывать **итераторы**, другие допы для неё делать не надо.

5. Реализуйте шаблонный метод `try_emplace`, который позволит вставлять элементы в таблицу следующим образом:
    ```C++
    class A {
    public:
        A(int x, double y, const std::string& z) {
            // ...
        }
    }
    FlatMap<std::string, A> map_of_a;
    map_of_a.try_emplace("key1", 3, 5.6, "test"); // создан и вставлен в таблицу объект A(3, 5.6, "test") по ключу "key1"
    ```
    Если такой ключ уже есть в таблице, метод ничего не делает.

6. Сделайте так, чтобы ваш шаблонный класс `FlatMap` корректно работал с типами ключей и значений, у которых запрещено копирование или перемещение (но не оба сразу). Например, у `std::unique_ptr` запрещено копирование.

## Подзадача 3. Парсер CSV

Формат CSV format: табличные данные могут быть представлены как текстовый файл с разделителем `\n` между строками и символом `,` для разделения ячеек внутри строки. Считаем что данные символы не встречаются внутри данных.

Напишите класс, делающий возможным следующую потоковую работу с CSV:
```C++
int main()
{
   CSVParser<int, string> parser("test.csv", 0 /*skip first lines count*/);
   for (std::tuple<int, string> rs : parser) {
       cout<<rs<<endl;
   }
}
```

Потоковая обработка подразумевает lazy (ленивое) чтение строк. Вы не можете читать весь файл сразу. Чтение происходит по 1 строке в двух местах: при создании итератора и при его инкременте; `operator*` у итератора не читает, а только возвращает ранее прочитанный кортеж. Еще чтение возможно для скипа первых N строк в конструкторе, если пользователь это запросил. Таким образом необходимо реализовать [InputIterator](https://en.cppreference.com/w/cpp/named_req/InputIterator) для чтения данных в CSV файле. 

При сдаче продемонстрировать:
1. Чтение валидного файла при помощи CSVParser и печать его содержимого в консоль при помощи вашего принтера кортежей (как в условии).
2. Создание одновременно нескольких итераторов от одного парсера и независимое чтение из них.
3. Чтение нескольких ошибочных файлов и/или не подходящих по типам.

Дополнительно:
