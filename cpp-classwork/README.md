# Задачи для очной работы по курсу ООП (C++), ФИТ НГУ, 2 курс

## Тема 1. Введение

Выполните [задачу 0](https://docs.google.com/document/d/16jJOQ2EGlAvqq2sUJdwXgaQYUivRX50o-vSxLPpC2ck/edit?tab=t.0) из практических задач на сайте [НГУ ООП](https://sites.google.com/site/nguoop/%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81?authuser=0).

## Тема 2. Классы

Реализуйте класс-обёртку для массива строк переменной длины со следующими методами:

```C++
class Array {
public:

    // конструктор
    Array();

    // деструктор
    ~Array();

    // получить текущий размер
    std::size_t size() const;

    // очистка, после неё текущий размер = 0
    void clear();

    // положить значение по данному индексу. Если индекс больше или равен текущему размеру, увеличить размер
    void put(std::size_t index, std::string value);

    // получить значение по индексу. Если индекс больше или равен текущему размеру, вернуть пустую строку
    std::string get(std::size_t index);

private:
    std::string* data_; // массив
    std::size_t size_;  // текущий размер массива (количество элементов)
}
```

## Тема 3. Константность, ссылки, копирование

Добавьте конструктор копирования для вашего класса `Array`. Он имеет сигнатуру `Array(const Array&)`.

## Тема 4. Перегрузка операторов

Реализуйте следующие операторы для вашего класса `Array`:
1. Копирующее присваивание (`operator=`).
2. Доступ по индексу (`operator[]`).
3. Сравнение и неравенство (`operator==` и `operator!=`). Реализуйте по две версии: как член класса и как отдельная функция.

## Тема 5. Наследование

Реализуйте класс `Container` с полем `size_` и методом `size()`, удалите из класса `Array` это поле и метод, унаследуйте `Array` от `Container`.

## Тема 6. RAII и безопасность исключений

Добейтесь, чтобы все методы класса `Array` обеспечивали как минимум строгую гарантию безопасности исключений.

## Тема 7. Виртуальные функции

Сделайте метод `size` класса `Container` чисто виртуальным. Удалите все поля из класса `Container`. Реализуйте метод `size` в `Array`. Реализуйте класс `List` - односвязный список строк (`std::string`) с методами `add` и `size` (остальные по желанию), который также наследуется от `Container`. Правильно реализуйте деструкторы всех классов. Реализуйте функцию, которая принимает котейнер и выводит на экран его размер.

## Тема 8. Паттерны проектирования: фабричный метод и итератор

1. Реализуйте фабричный метод, который создаёт либо `Array`, либо `List`, в зависимости от переданного аргумента, и возвращает указатель на `Container` (можно - умный указатель).
2. Реализуйте методы `begin()` и `end()` для `Array`, которые возвращают итератор на элементы массивы (в данном случае это будет просто указатель на элемент массива, то есть `std::string*`).
3. Реализуйте методы `begin()` и `end()` для `List`. Придумайте, какой тип они должны возвращать, и какие операции должны быть реализованы у этого типа, чтобы следующий код компилировался и работал (выводил содержимое списка на экран). Реализуйте этот тип и необходимые операции.
```C++
List list = ...
for (auto it = list.begin(); it != list.end(); ++it) {
    std::cout << *it << "\n";
}
```

## Тема 9. Введение в шаблоны (templates)

1. Превратите ваш класс `Array` в шаблонный класс с одним аргументом - типом коллекции. Сохраните наследование от `Container` и, если необходимо, `Container` также превратите в шаблонный класс.
2. Аналогично сделайте с классом `List`.

Все функции-друзья должны продолжать работать. Возможно, некоторые из них (или все) также придётся превратить в шаблонные функции. Итераторы также должны продолжать работать (их тоже нужно сделать шаблонными).

## Тема 10. Множественное и виртуальное наследование

1. Создайте класс `CountedObject`, у которого будет приватное целочисленное константное поле `counter`, которое будет устанавливаться в уникальное значение в конструкторе (используйте инкрементируемое статическое поле для обеспечения уникальности). Также у него будет метод получения значения `counter`.
2. Унаследуйте виртуально классы `Array` и `List` от `CountedObject` (при этом их наследование от `Container` остаётся).
3. Создайте класс `Chimera`, который наследуется от `Array` и `List`. Метод `put` переопределите так, чтобы он клал новый объект и в массив, и в список.

